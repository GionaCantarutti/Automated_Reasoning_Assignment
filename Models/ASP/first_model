%instance

#const n = 5.

size(n).
%the two faces of a stone and the count of how many such stones there are
stone ((0,1),1).
stone ((1,0),1).
stone ((1,1),1).
stone ((2,0),1).
stone ((2, 2),1).
stone ((6,2),1).
stone ((2,3),1).
stone ((3,5),1).
stone ((5,2),1).
stone ((5,0),1).
stone ((0,0),1).
stone ((5,2),1).
stone ((5,2),1).
stone ((0,2),1).
stone ((6,1),1).

%%%%% RULES %%%%%
%time goes from 0 to n^2
time (0..(n**2)).
% space-time coordinates
coordinates (1..n, 1..n, 0..(n**2)).
%if a stone exists, its opposite also exists
reversed (A, B) :- stone((B, A), _).
%if a stone exists, its two combinations also exist
combination (A,B) :- stone ((A,B), _).
combination (A,B) :- stone((B,A), _).
%placed domain
:- placed(_, _, _, N1, N2), not combination(N1, N2).
:- placed(X, Y, T, _, _), not coordinates(X, Y, T).
%each cell should have at most one stone
T1 = T :- placed(X, Y, T, _, _), placed(X, Y, T1, _, _).
N1 = N :- placed(X, Y, _, N, _), placed(X, Y, _, N1, _).
N1 = N :- placed(X, Y, _, _, N), placed(X, Y, _, _, N1).
%0 { placed (X, Y, T, N1, N2) : time(T), combination(N1, N2) } 1 :- X=1..n, Y=1..n.
%each stone can only be used as many times as how many copies of it are aviable
C <= N :- stone ((A, B), N), C = #count {placed (X, Y, T, A, B) : time(T), X=1..n, Y=1..n }.
%if a stone is placed at an even time then the following placement is reversed
placed (X, Y, T+1, N2, N1) :- placed (_, _, T, N1, N2), (T\2) = 0, stone((N1, N2), _), reversed (N2, N1), coordinates(X, Y, T).
%there is at most one placement per time step
T = T1 :- placed(X, Y, T, A, B), placed(X, Y, T1, A, B).

#maximize { 1, (X, Y, T, N1, N2) : placed(X, Y, T, N1, N2) , coordinates(X, Y, T), combination(N1, N2) }.
#show placed/5.